<html>
	<head>
		<title>reverse proxy</title>
	</head>
	<body>
		<section>
			<p>
				My last e-mail had a subject line of "[msr.sigcf] <i>guerrilla</i> storage" and a body with an MD5 of <i>0b5fcef85b8fecdeeb425634dc14c238</i>.
				An HTML version has an MD5 of <i>0081e6617d625091bb5a1698fb5cf8d4</i>.
				These can be found in my content-addressable storage described in an e-mail I sent out with an MD5 of <i>0d7177f4b08b7f2f81579a37073ac645</i>, which is served up at such URLs as <a href="http://archive.is/FyoSb">http://archive.is/FyoSb</a> and <a href="http://calcnerd256.dyndns.org:15211/cas/md5=0d7177f4b08b7f2f81579a37073ac645">http://calcnerd256.dyndns.org:15211/cas/md5=0d7177f4b08b7f2f81579a37073ac645</a> and <a href="https://raw.githubusercontent.com/calcnerd256/cas-data/master/data/md5%3D0d7177f4b08b7f2f81579a37073ac645">https://raw.githubusercontent.com/calcnerd256/cas-data/master/data/md5%3D0d7177f4b08b7f2f81579a37073ac645</a>.
				I sent this last e-mail on Friday, December 6, 2019 at 21:46:34 CST (<i>i.e.</i>, -0600) or 1575690394.
			</p>
			<p>
				My last e-mail had some typos.
				I referred ambiguously to the one before it in a context where the antecedent appeared to be a different e-mail.
				I think there was another typo, but I've already forgotten it.
				I had also implied to someone that I was going to mention something they'd done, but I forgot to, so I'll do that in this one.
			</p>
		</section>
		<section>
			<p>
				I got another subscriber.
			</p>
		</section>
		<section>
			<p>
				I found out that one of my friends is already doing this sort of thing.
				His newsletter can be found here: <a href="https://tinyletter.com/sambleckley/">https://tinyletter.com/sambleckley/</a>.
				I didn't get around to reading it yet, and I haven't vetted it for content, so I don't mean to imply that his audience and mine will exactly line up, so take this link with the grain of salt that comes from not being a direct recommendation.
				Who knows?
				Maybe you'll like his better than mine.
			</p>
		</section>
		<section>
			<p>
				I said I might talk about my reverse proxy.
			</p>
			<p>
				In my world, a proxy is a webserver that sits in front of another webserver.
				To most people who use Web proxies, this means that there is one webserver that sits right next to their browser (probably on the same machine) and mediates all of their requests to every website they visit.
				A reverse proxy is when the proxy sits right next to the website and midates all requests to it from any browser.
				I don't really care about this distinction, because I just think of it as whenever there's some intermediary somewhere involved, and I want to make more exotic graphs than those described by those two classes of proxy.
				I don't, however, want to generalize all the way away from Web proxies at this time.
				So, to me, a proxy is a program that sits in between a client and a server on the Web and acts as server to the client and as client to the server.
				Maybe it simply forwards the request; maybe it transforms it in some way; maybe it caches it.
				Caching proxies are definitely a thing.
				Content-delivery networks are basically geographic caching (reverse) proxies for static content, by design.
			</p>
			<p>
				The reverse proxy I want to talk about today is not a transforming proxy.
				It merely forwards requests and responses.
				Its job is to graft multiple namespaces together to make them look like one coherent website when they are actually served up by separate webservers that may be written in different languages and might not even be running on the same computer.
				When your browser request a webpage, there's the host part of the URL and the rest of it (which can be split into the resource path and the query, but that difference doesn't matter here).
				The host part says what computer to talk to, and the rest of it says what to ask it for.
				The part that says what to ask it for has a "path" part to it, which is made of components separated by the forward slash character.
				These can be thought of as a hierarchical namespace, like a tree of folders in a filesystem, but they don't actually have to be implemented by a finite collection of folders in one-to-one correspondence with their URLs.
				One of the two things my reverse proxy does is let me re-arrange these namespaces.
				It doesn't transform the pages that come back, so it does make it possible for me to break links that use relative paths, but I can exercise some discipline in how I structure those links and how I graft trees together to make it so that they don't break; the same can't be said for other people's content that I choose to include in my tree, so there's a trade-off I have to manage there.
				The other thing my reverse proxy does is let me pretend that several hosts are one host.
				When the Web gained more abilities, more classes of exploits needed to be prevented.
				One way that the designers of the Web standards came up with to mitigate risk was to restrict ways that webpages hosted by different computers could interact with each other.
				Well, not actually different computers <i>per se</i>, but different "domains" as they're called (actually, it's more complicated than domains, so they call them "origins" instead).
				Anyway, I want to circumvent some of those protections, but I don't want to lump all of my webservers together into one program.
				I want a bunch of small webservers that each do one thing, and I want to write browser-based applications that can freely use all of these servers almost directly.
				There are ways for the webserver for one origin to tell the browser that they want to allow code from another origin to access it, but for my own applications I want the insecure-by-default way that doesn't require special effort for each pairwise collaboration.
				So, not only does my reverse proxy let me re-arrange the tree of resources (pages) that one of my servers provides, it also allows me to grab these from multiple servers and present them to my browser as a single website.
			</p>
			<p>
				My proxy (reverse proxy, that is, but I'm dropping the moniker for the rest of this discussion unless it helps resolve ambiguity) receives a request, forwards it to someone else, and forwards the response from that someone-else back to whoever sent the original request.
				I'll sometimes refer to the someone-else as "upstream" (adjective) of the proxy, or just "the upstream" (noun) by synecdoche/metonymy.
				But how does it decide what upstream to use for a given request?
				I already described that what it is doing primarily is transforming the tree of resources, so we know that it bases its decision on the aforementioned non-host part of the URL (the address of the page).
				There are several ways I could implement the mapping that transforms the requested resource's URL path to the full URL of the upstream server's resource.
				One way would be to have a finite lookup table.
				This could be stored in a file.
				Another way would be to have a list of prefixes and the upstreams they correspond to, possibly including (in the suffix of the upstream) a prefix to graft onto, so as to descend into the namespace of the upstream rather than grafting its whole namespace in.
				The option I'd prefer to go with, however, is to delegate this behavior to another program.
				Actually, to another webserver.
				This allows the proxy to do one thing&mdash; the proxying of requests &mdash;and prevents it from being burdened with the responsibility of making decisions about where to proxy them to.
				I can then design that other webserver (the one that makes the decisions) however I want, implement it however I want, and change my mind about any of those decisions whenever I want.
				I can also allow infinite structures of grafting, instead of having to carefully choose what kinds of grafting I want to allow up-front.
				Most of this is also true if I have the proxy run a program for each request instead of querying a webserver, but I like webservers.
				I can even design my proxy so that, for all but a finite set of request URI path prefixes, it can query itself to find out where to forward things.
				Then the configuration webserver doesn't have to be a monolith either.
			</p>
			<p>
				I already implemented a version of this that takes the URL for its configurator (the webserver that makes those namespace-grafting decisions) as a command-line argument.
				It doesn't do the self-reference that I described, but I could build that into the configurator without a rewrite of the proxy if I'm careful.
				I also want to integrate it with service directory (as described in an e-mail with an MD5 of <i>25bbab5c07fe62f2030d45567ed9849a</i>), but that could also be done in the configurator and the launch script.
			</p>
		</section>
		<section>
			<p>
				Maybe next time I'll talk about some applications of this proxy.
				Or maybe I'll talk about test-driven development.
				Or Lisp.
				Or GUIs, or music.
				I don't know.
				Probably the proxy.
			</p>
		</section>
		<section>
			<p>
				Don't take my solicitation of feedback as nagging.
				If you don't have anything you feel like saying, don't say anything.
				If you do, though, feel free.
			</p>
			<p>
				And if you have something to say that you think will offend me and for that reason aren't saying it, maybe say it anyway.
				But preface it with a warning so that I know that you know that you suspect that you're offending me.
				If, on the other hand, there is a consequence to what you aren't saying, and you want to avoid causing the part of the consequence that happens on my side (such as in the offense example), and you doubt my ability to prevent that part of the consequence, then ask me to place a bet on my ability to prevent that part of the consequence (<i>e.g.</i>, "I bet you $5 you'll overreact to this in a way that ruins <i>X</i> thing over here in <i>Y</i> objectively-verifiable way."), if possible, unless asking me to place the bet would reveal a secret to me that you wish to keep from me, in which case I guess there isn't much that can be done about it without bringing in a third party for secrecy escrow.
				Anyway, my point is: let's keep the lines of communication open.
				I've seen too many organizations experience unnecessary drama because people couldn't talk to each other, and I don't want to be the cause of such a blockage.
				But I'm only human, so we have to work around my frailty.
			</p>
		</section>
		<section>
			<p>
				Maybe tomorrow I should start a weekly digest to index what topics I've visited in each mailing.
				Tagging (for topics) is hard, though, since I never know what I'll want to find later.
			</p>
		</section>
	</body>
</html>
